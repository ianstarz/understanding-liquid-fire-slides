<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Understanding liquid-fire</title>

    <meta name="description" content="Ian Storz's presentation on liquid-fire for the 7-29-2015 Denver Ember.js meet up.">
    <meta name="author" content="Ian Storz">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        
        <section>
          <h2>Understanding liquid-fire</h2>
          <p>by @ianstarz</p>
          <em>Denver Ember.js meetup 7-29-15</em>
        </section>

        <section>
          <p>First, a few thoughts on design...</p>
        </section>

        <section>
          <video controls>
            <source src="videos/ef4-on-design.mp4" type="video/mp4">
          </video>
          <small><em>https://www.youtube.com/watch?v=vq_BcIFM8Rc</em></small>

          <aside class="notes">
            (before the video plays)
            Here is a clip of Edward Faulkener at the Silicon Valley Ember.js meet up in April.

            (after the video plays)
            Edward's talk at the Silicon Valley Ember.js meet up is an excellent resource for liquid-fire, and I got a lot out of it on my second time watching it. If you haven't seen this talk or the one he gave at Ember Conf, I'd highly recommend it as he does a lot of cool stuff with liquid-fire and other aspects of Ember CLI.

            But let's talk for a moment about placing our designs in context.
          </aside>            
        </section>

        <section>
          <img src="images/lean-crunch.jpg" />

          <aside class="notes">
            Take for instance this product. Does anyone know what it is? Admittedly, this is actually a conceptual design for Kashi Go Lean Crunch cereal, so this example is somewhat contrived, but it was designed nonetheless. Perhaps we can make sense of this design in context.
          </aside>
        </section>

        <section>
          <img src="images/cereal-aisle.jpg" />

          <aside class="notes">
            In the very specific building and task for grocery shopping, and even more specifically, in the cereal aisle, we have pretty standardized expectations for what the products will look like.
          </aside>
        </section>

        <section>
          <img src="images/lean-crunch.jpg" />

          <aside class="notes">
            <p>Now, a product like this...</p>
          </aside>
        </section>

        <section>
          <img src="images/cereal-aisle.jpg" />

          <aside class="notes">
            ..in this environment, might do one of three things: 1) it might stand out to you; 2) it might blend in naturally; 3) or it might offend you. Each one of these outcomes has a variety of different consequences that should be considered, but ultimately, you want to start with one simple consideration: what effects does this physical object have in its environment.
          </aside>
        </section>

        <section>
          <img src="./images/dieter-rams-radio.jpg" />

          <aside class="notes">
            The way we perceive the world is a natural process. Our brains have evolved to quickly and efficiently place objects in the context of our world. This is why good design is so often "invisible". Good design is frictionless when being placed in our surroundings.
          </aside>
        </section>

        <section>
          <img src="./images/doorstep.jpg" />

          <aside class="notes">
            Contrarily, unfunctional design can be jarring. It calls attention to itself, and away from the purpose it is trying to fit. The lines and composition might be pleasant, but the object's function in the physical world can be quixotic.
          </aside>
        </section>

        <section>
          <video controls>
            <source src="videos/ef4-on-abstraction.mp4" type="video/mp4">
          </video>
          <small><em>https://www.youtube.com/watch?v=vq_BcIFM8Rc</em></small>

          <aside class="notes">
            (before video plays)
            Here is another clip of Edward talking about abstraction and it's cognitive load on the brain.

            (after video plays)
            Edward is trying to convey two points here. One, the motion design we're interested in is animation that helps the user understand how they affect the state of the application. And two, that even for abstract thinkers, using this motion design helps users consume abstraction.
          </aside>            
        </section>

        <section>
          <img src="./images/animation-paper-excerpt.png" />
          <small><em>http://www.selflanguage.org/_static/published/animation.pdf</em></small>

          <aside class="notes">
            Here is an excerpt from a 1993 paper by Standford professor Bay-Wei Chang and Sun Microsystems engineer David Ungar titled "Animation: From Cartoons to the User Interface". In the abstract they state "When the user cannot visually track the changes occurring in the interface, the causal connection between the old state of the screen and the new state of the screen is not immediately clear. How are the objects now on the screen related to the ones which were there a moment ago? Are they the same objects, or have they been replaced by different objects? What changes are directly related to the userâ€™s actions, and which are incidental? To be able to efficiently and reliably interpret what has happened when the screen changes state, the user must be prepared with an expectation of what the screen will look like after the action. In the case of most interactions in unanimated interfaces, this expectation can only come by experience; little in the interface or the action gives the user a clue about what will happen, what is happening, or what just happened."
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/scrolling-no-animation.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>

          <aside class="notes">
            We encounter these ideas in user experience and user interface design, and even though we as user experience designers understand why something might behave like this.
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/scrolling-animated.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>
          
          <aside class="notes">
            When we simulate a physical experience, the experience is easier to understand and actually takes away cognitive load, even though you are adding to the experience. There are many more frames between the animated scroll vs the non animated scroll, but they help the user instead of making them think harder. This should be a motivation as motion designers. We should ask ourselves: how does this motion help decrease the cognitive load on our users?
          </aside>
        </section>

        <section>
          <img src="./images/58-frames-tweet.png" />

          <aside class="notes">
            Now this doesn't come without more work. Motion design is not easy, and it often needs to be thought of during the design process, which adds more work in the mock phase.
          </aside>
        </section>

        <section>
          <img src="./images/transitional-interfaces/new-item-no-animate.gif" />
          <small><em>https://medium.com/@pasql/transitional-interfaces-926eb80d64e3</em></small>

          <aside class="notes">
            But showing this to a client or stakeholder...
          </aside>
        </section>

        <section>
          <img src="./images/transitional-interfaces/new-item-pop-in.gif" />
          <small><em>https://medium.com/@pasql/transitional-interfaces-926eb80d64e3</em></small>

          <aside class="notes">
            ...does not have the same affect as does showing this,
          </aside>
        </section>

        <section>
          <img src="./images/transitional-interfaces/new-item-slide-in.gif" />
          <small><em>https://medium.com/@pasql/transitional-interfaces-926eb80d64e3</em></small>

          <aside class="notes">
            or this.
          </aside>
        </section>

        <section>
          <p>Not all fluff</p>

          <aside class="notes">
            Motion design can go beyond taking the cognitive load off of the user. Motion design can nudge the user experience in a particular direction.
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/stateful-toggle.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>
          
          <aside class="notes">
            A stateful toggle invisibly reminds us how to get back to the previous state.
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/context-based-hiding.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>
          
          <aside class="notes">
            Context based hiding can draw focus to what's important.
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/expanding-comments.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>
          
          <aside class="notes">
            Or gently invite the user into functionality. Here we see the comment form is easy and simple, so we may be more inclined to comment. Once we get into the flow and see there are two more fields, we may not mind as much since we're already in the flow. Where as seeing the three fields to begin with may be perceived as too much effort to leave a comment.
          </aside>
        </section>

        <section>
          <img src="./images/smashing-magazine/stickey-label.gif" />
          <small><em>http://www.smashingmagazine.com/2013/10/smart-transitions-in-user-experience-design/</em></small>
          
          <aside class="notes">
            Here we might continue to read, because we are persuaded by motion techniques that convey transition and progression.
          </aside>
        </section>

        <section>
          <p>Let's not get too carried away though.</p>
        </section>

        <section>
          <img src="./images/valhead/apple-odd-motion-non-fitting.gif" />
          <small><em>http://valhead.com/2013/11/25/what-are-your-transitions-saying/</em></small>

          <aside class="notes">
            Take this unnecessary animation from Apple. The addtional "sugar" they ease in and out with is especially distracting. Like the case of our conceptual cereal box, this physical interaction feels slightly out of place.
          </aside>
        </section>

        <section>
          <img src="./images/beyond-kinetic/dots.gif" />
          <small><em>http://www.beyondkinetic.com/motion-ui-design-principles/</em></small>

          <aside class="notes">
            In the game of Dots, however, the playfulness of the motion is warranted by the physical space it occupies, and the motion design has a common thread from the way we interact with the menus to the way we play the game.
          </aside>
        </section>

        <section>
          Material Design

          <aside class="notes">
            Thinking about simulating the physical world, naturally leads into material design, which is guided by 3 principles.
          </aside>
        </section>

        <section>
          <p>Material is metaphor</p>
          <img width="400px" height="auto" src="./images/materialdesign_principles_metaphor.png" />

          <aside class="notes">
            Material as a metaphor is easy for us to understand. We use metaphors all the time in computer science. For example, "bugs" or coding "closer to the metal" are metaphors that help anchor abstract ideas in the world of the physical.
          </aside>
        </section>

        <section>
          <p>Bold, graphic, intentional</p>
          <img width="400px" height="auto" src="./images/materialdesign_principles_bold.png" />

          <aside class="notes">
            I believe this principle to be more subjective, and open to interpretation. Take it or leave it, but this is not what we're interested in right now.
          </aside>
        </section>

        <section>
          <p>Motion provides meaning</p>
          <img width="400px" height="auto" src="./images/materialdesign_principles_motion.png" />

          <aside class="notes">
            This is what we're interested in. Motion provides meaning is the 3rd principle of Material Design, and it falls in line with the philosophies of liquid fire.
          </aside>
        </section>

        <section>
          <p>The meanings...</p>

          <aside class="notes">
            Rachel Nabors provides us with some examples of this meaning in her article on A List Apart.
          </aside>
        </section>

        <section>
          <p>Causality</p>
          <img width="600px" height="auto" src="./images/a-list-apart/animation-principles_causality.gif" />
          <small><em>http://alistapart.com/article/web-animation-at-work</em></small>

          <aside class="notes">
            Here we see the meaning of causality. When a user affects something, and they feel they've affected something, it's because the motion happened after their interaction and not before. When it happens before, the system seems to "act on its own".
          </aside>
        </section>

        <section>
          <p>Feedback</p>
          <img width="600px" height="auto" src="./images/a-list-apart/animation-principles_feedback.gif" />
          <small><em>http://alistapart.com/article/web-animation-at-work</em></small>

          <aside class="notes">
            Feedback provides the user with a sense that they have affected something. This way, if the user experience hangs, the user can suspect the system is hanging by something other than whether or not they actually pressed the button.
          </aside>
        </section>

        <section>
          <p>Progression</p>
          <img width="600px" height="auto" src="./images/a-list-apart/animation-principles_progression.gif" />
          <small><em>http://alistapart.com/article/web-animation-at-work</em></small>

          <aside class="notes">
            This is the base principle for animated spinners, but can be applied in many more creative ways. Progression is often used to keep users engaged while they are not necessarily affecting the system, but could also be used to show how incremental actions affect the system.
          </aside>
        </section>

        <section>
          <p>Relationships</p>
          <img width="600px" height="auto" src="./images/a-list-apart/animation-principles_relationships.gif" />
          <small><em>http://alistapart.com/article/web-animation-at-work</em></small>

          <aside class="notes">
            One of the most important meanings behind motion is spatial relationship, which can help orient the user within their viewport. When we feel like the things we are seeing through the viewport are a part of a larger connected system, then when we move through the system we don't feel disjointed.
          </aside>
        </section>

        <section>
          How do we do this?

          <aside class="notes">
            There of course are many ways to animate things on the web. Dozens of animation libraries that vary from using canvas, to SVG, to WebGL, that all provide a variety of purposes.
          </aside>
        </section>

        <section>
          <p>How do we do this in Ember with liquid-fire?</p>
          <ol>
            <li class="fragment fade">
              Use motion design to understand application state changes
            </li>
            <li class="fragment fade">
              To implement motion design in a way that plays nice with Ember
            </li>
          </ol>

          <aside class="notes">
            Taking the principles we just covered we can more concretely define the goals of liquid-fire which are: 1) To use animation specifically to provide the user with natural information on how they are affecting the application state, and 2) to do so in a way that goes with the flow of the framework instead of fighting it.
          </aside>
        </section>

        <section>
          <p>Animations in Ember without liquid-fire</p>

          <aside class="notes">
            To appreciate what liquid-fire does for us, let's first think about how we could animate without it. Also, because Ember prescribes storing the state of your application in the URL, we'll especially be interested in animating between routes.
          </aside>
        </section>

        <section>
          <p><em>/circle</em></p>
          <svg width="400" height="400">
            <circle cx="200" cy="200" r="100" fill="blue"></circle>
          </svg>

          <aside class="notes">
            For instance, we have a route called "circle"...
          </aside>
        </section>

        <section>
          <p><em>/square</em></p>
          <svg width="400" height="400">
            <rect x="100" y="100" width="200" height="200" fill="red"></circle>
          </svg>

          <aside class="notes">
            ...and a route called "square", and we move between these two routes.
          </aside>
        </section>

        <section>
          <p>Without animation</p>

          <aside class="notes">
            Without animation, Ember's architecture goes through the following sequence to transition between the two routes.
          </aside>
        </section>

        <section>
          <p><em>/circle</em></p>
          <svg width="400" height="400">
            <circle cx="200" cy="200" r="100" fill="blue"></circle>
          </svg>

          <aside class="notes">
            When we leave the circle route, Ember's router will begin the transition...
          </aside>
        </section>

        <section>
          <p><em>/circle</em></p>
          <svg width="400" height="400">

          </svg>

          <aside class="notes">
            ...which involves tearing down the current route...
          </aside>
        </section>

        <section>
          <p><em>/square</em></p>
          <svg width="400" height="400">

          </svg>

          <aside class="notes">
            ...representing the new route hierarchy to the rendering layer...
          </aside>
        </section>

        <section>
          <p><em>/square</em></p>
          <svg width="400" height="400">
            <rect x="100" y="100" width="200" height="200" fill="red"></circle>
          </svg>

          <aside class="notes">
            ...which the rendering layer then populates the route.
          </aside>
        </section>

        <section>
          <p>Steps needed to animate</p>
          <ol style="font-size: 32px;">
            <li class="fragment fade">Route knows it's deactivating (exiting the circle route)</li>
            <li class="fragment fade">Router determines which route we're going to (the sqaure route)</li>
            <li class="fragment fade">Service we implement saves the view we're about to tear down.</li>
            <li class="fragment fade">Tear down route, but allow service to keep copy of the view in the outlet</li>
            <li class="fragment fade">Render the new route, but hide and position the new element (the square)</li>
            <li class="fragment fade">Animate the old value (the circle) off the screen to the left</li>
            <li class="fragment fade">Animate the new value (the square) onto the screen from the right</li>
            <li class="fragment fade">Tear down the old value (remove the circle from the DOM)</li>
          </ol>

          <aside class="notes">
            This is all fine and dandy, until we want to do a simple sliding transition. To animate the transition. We need both of the routes, both of the views available during the duration of the transition. In this case the steps to animate might look like this.

            (Step through list)

            Woah, that's alot, and worse yet it is concerning our Router, Routes, and View objects all with how things should animate. That's a lot of work! And it feels like we're fighting the framework.
          </aside>
        </section>

        <section>
          <p>The main principles of liquid-fire</p>
          <ol>
            <li class="fragment fade">Use template helpers to keep track of old and new values</li>
            <li class="fragment fade">Defer to a transition map when asking should we animate, and if so, how?</li>
          </ol>

          <aside class="notes">
            This brings us to the two main principles of liquid-fire, which are these. (step through principles) All of the complexity of animating between state changes is now handled by liquid-fire by minimal impact to your templates and by introducing a new function (the transition map) into your application. You won't need to touch your router, routes, or views to make any of this work!
          </aside>
        </section>

        <section>
          <p>Template helpers</p>

          <aside class="notes">
            Let's investigate these two principles in detail. The tempalte helpers are responsible for two things: 1) Saving the new and the old values when something changes, 2) adding some layout to help with animation.
          </aside>
        </section>

        <section>
          {{ liquid-outlet }}
        </section>

        <section>
          {{ liquid-bind }}
        </section>

        <section>
          {{ liquid-if }}
        </section>

        <section>
          <p>The additional markup</p>
          <img src="./images/liquid-fire-markup.png" />
        </section>

        <section>
          <p>The additional markup</p>
          <img src="./images/liquid-container-style.png" />
        </section>

        <section>
          <p>The additional markup</p>
          <img src="./images/liquid-child-style.png" />
        </section>

        <section>
          <p>The transition map</p>
        </section>

        <section>
          <pre><code class="javascript" data-trim style="font-size: 18px;">
// app/transitions.js
export default function() {
  this.transition(
    this.fromRoute('circle'),
    this.toRoute('square'),
    this.use('toLeft')
  );
}
          </code></pre>

          <aside class="notes">
            Now this only goes in one direction.
          </aside>
        </section>

        <section>
          <pre><code class="javascript" data-trim style="font-size: 18px;">
// app/transitions.js
export default function() {
  this.transition(
    this.fromRoute('circle'),
    this.toRoute('square'),
    this.use('toLeft')
  );

  this.transition(
    this.fromRoute('square'),
    this.toRoute('circle'),
    this.use('toRight')
  );
}
          </code></pre>

          <aside class="notes">
            To go in the other direction, too, you could do this.
          </aside>
        </section>

        <section>
          <pre><code class="javascript" data-trim style="font-size: 18px;">
// app/transitions.js
export default function() {
  this.transition(
    this.fromRoute('circle'),
    this.toRoute('square'),
    this.use('toLeft'),
    this.reverse('toRight')
  );
}
          </code></pre>

          <aside class="notes">
            But this is so common that you can just do this.
          </aside>
        </section>

        <section>
          demo
        </section>

        <section>
          <h3>Thank you :D</h3>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>
